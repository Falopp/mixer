# Epic Mixer üå™Ô∏è
### Un Orquestador Experimental de Ofuscaci√≥n de Transacciones Multi-Capa para BSC

[![Python 3.9+](https://img.shields.io/badge/python-3.9+-blue.svg)](https://www.python.org/downloads/)
[![License: MIT](https://img.shields.io/badge/Licencia-MIT-green.svg)](https://opensource.org/licenses/MIT)
![Estado: Experimental](https://img.shields.io/badge/estado-experimental-red.svg)

**Epic Mixer** es un framework de l√≠nea de comandos dise√±ado para la investigaci√≥n avanzada y experimental de la privacidad en transacciones de blockchain. Funciona como un **orquestador** sofisticado, ejecutando estrategias definidas por el usuario para fragmentar y ofuscar los rastros de las transacciones en la Binance Smart Chain (BSC) a trav√©s de m√∫ltiples capas y sistemas.

---

## ‚ö†Ô∏è EXTREMADAMENTE IMPORTANTE: Esta es una Herramienta Experimental

**√öSALA BAJO TU PROPIO E INMENSO RIESGO. ESTA NO ES UNA HERRAMIENTA PARA ACTIVIDADES ILEGALES. ES UN FRAMEWORK DE INVESTIGACI√ìN.**

-   **Alto Riesgo de P√©rdida de Fondos**: Este software es complejo y experimental. Una mala configuraci√≥n, errores de red o bugs no descubiertos pueden y probablemente conducir√°n a la **p√©rdida total e irreversible de tus fondos**.
-   **Sin Garant√≠as de Privacidad**: Aunque su objetivo es complicar dr√°sticamente el an√°lisis de transacciones, **no puede garantizar un anonimato absoluto**. Adversarios con suficientes recursos podr√≠an rastrear los fondos.
-   **Solo para Fines Educativos y de Investigaci√≥n**: Esta herramienta fue desarrollada para explorar conceptos de ofuscaci√≥n de transacciones multi-sistema. Los desarrolladores no se hacen responsables de ning√∫n uso, mal uso o p√©rdida de activos.

---

## üèõÔ∏è Conceptos Clave y Arquitectura

Epic Mixer no es un simple "tumbler". Es un **orquestador** que t√∫ diriges. La filosof√≠a central es la **ofuscaci√≥n multi-capa dirigida por estrategias**.

1.  **Dirigido por Estrategia**: Defines el plan de mezcla completo en un archivo `strategy.json`. Esto incluye el n√∫mero de wallets, las rondas de mezcla y, lo m√°s importante, los **brazos de distribuci√≥n** (distribution legs).
2.  **Distribuci√≥n Multi-Capa**: En lugar de un √∫nico destino, los fondos se fragmentan y se env√≠an a trav√©s de m√∫ltiples "brazos", tales como:
    -   **Exchanges**: Una porci√≥n de los fondos puede ser enviada a una direcci√≥n de dep√≥sito que t√∫ proporciones de un exchange externo.
    -   **Pools de Privacidad (Simulado)**: Una porci√≥n puede ser enviada a una wallet intermediaria para simular la interacci√≥n con un protocolo de privacidad como Tornado Cash.
    -   **Fragmentaci√≥n Directa**: El resto puede ser distribuido directamente a tus wallets de destino finales.
3.  **No Custodial y Ef√≠mero**: La herramienta opera bajo un modelo de "Caja Fuerte". Genera un nuevo mnem√≥nico ef√≠mero y una direcci√≥n de dep√≥sito para cada sesi√≥n. **Nunca introduces tus claves privadas.** Env√≠as los fondos *a* la wallet temporal del script.
4.  **Reportes Encriptados**: Al finalizar, todos los datos de la sesi√≥n, incluyendo el mnem√≥nico ef√≠mero y las claves privadas generadas, se guardan en un archivo encriptado con contrase√±a. Sin la contrase√±a, los datos son in√∫tiles.

```mermaid
graph TD
    subgraph " "
        direction LR
        U[üë®‚Äçüíª T√∫]
    end

    subgraph "Proyecto Epic Mixer (Tu M√°quina Local)"
        RUN[‚ñ∂Ô∏è run_mixer.py]

        subgraph "Paquete epic_mixer"
            MAIN[üé¨ main.py<br/>(El Director)]
            subgraph "M√≥dulos de Utilidades"
                CONF[üìÑ utils/config.py]
                REP[üì¶ utils/reporting.py]
            end
            subgraph "M√≥dulos del N√∫cleo"
                W3U[üîó core/web3_utils.py]
                WLT[üîë core/wallets.py]
                ORCH[üå™Ô∏è core/orchestrator.py]
            end
            subgraph "Interfaz de Usuario"
                CLI[üó£Ô∏è cli.py]
            end
        end
    end
    
    subgraph " "
        direction LR
        BLOCKCHAIN[üåê Binance Smart Chain]
    end
    
    subgraph " "
        direction LR
        OUT[üìÑ reporte_encriptado.dat]
    end


    U -- "Ejecuta" --> RUN
    RUN -- "Inicia" --> MAIN
    
    MAIN -- "1. Carga estrategia" --> CONF
    MAIN -- "2. Crea sesi√≥n" --> WLT
    
    MAIN -- "3. Espera dep√≥sito" --> W3U
    W3U -- "Muestra QR" --> U
    U -- "Env√≠a BNB" --> BLOCKCHAIN
    BLOCKCHAIN -- "Detecta fondos" --> W3U
    
    W3U -- "Notifica a" --> MAIN
    MAIN -- "4. Pide datos" --> CLI
    CLI -- "Pregunta destinos y pass" --> U
    U -- "Introduce datos" --> CLI
    CLI -- "Devuelve a" --> MAIN
    
    MAIN -- "5. ¬°EJECUTAR!" --> ORCH
    ORCH -- "Env√≠a TXs" --> BLOCKCHAIN
    
    ORCH -- "Finalizado" --> MAIN
    MAIN -- "6. Crea reporte" --> REP
    REP -- "Guarda archivo" --> OUT
```

---

## üìã Requisitos

-   Python 3.9+

## üöÄ Instalaci√≥n y Configuraci√≥n

1.  **Clona el Repositorio**:
    ```bash
    git clone <URL_DE_TU_REPOSITORIO>
    cd epic-mixer
    ```

2.  **Crea un Entorno Virtual (Altamente Recomendado)**:
    ```bash
    python -m venv venv
    # En macOS/Linux:
    source venv/bin/activate
    # En Windows:
    venv\Scripts\activate
    ```

3.  **Instala las Dependencias**:
    ```bash
    pip install -r requirements.txt
    ```

4.  **Crea Tu Estrategia**:
    -   Copia el archivo de estrategia de ejemplo:
        ```bash
        cp strategy.json.example strategy.json
        ```
    -   **Edita `strategy.json`** para definir tu plan de ofuscaci√≥n.

---

## ‚ñ∂Ô∏è Modo de Uso

Todo el proceso se orquesta a trav√©s de la l√≠nea de comandos.

### Paso 1: Inicia el Mixer

Ejecuta el script desde el directorio ra√≠z. Usa el flag `--network` para operaciones en la red principal (Mainnet).

```bash
# Para ejecutar en la Testnet SEGURA y GRATUITA (POR DEFECTO)
python run_mixer.py

# Para ejecutar en la Mainnet REAL y RIESGOSA
python run_mixer.py --network mainnet
```

### Paso 2: Deposita los Fondos

El script generar√° y mostrar√° una direcci√≥n de dep√≥sito √∫nica y de un solo uso, junto con un c√≥digo QR. Env√≠a los BNB que deseas procesar a esta direcci√≥n desde tu wallet segura o exchange. El script esperar√° y detectar√° el dep√≥sito autom√°ticamente.

### Paso 3: Configura los Destinos

Una vez detectados los fondos, el script te guiar√° a trav√©s de una serie de preguntas basadas en tu archivo `strategy.json`:

-   Te pedir√° que proporciones las direcciones de dep√≥sito para cualquier "brazo" de tipo `exchange`.
-   Te preguntar√° cu√°ntas wallets finales deseas y sus direcciones.
-   Finalmente, te pedir√° una **contrase√±a segura** para encriptar el archivo de reporte final.

### Paso 4: Ejecuci√≥n y Reporte

Tras tu confirmaci√≥n final, el orquestador ejecutar√° la estrategia. Al completarse, generar√° un archivo encriptado llamado `mixer_report_encrypted_...dat`.

---

##  Herramienta de Desencriptaci√≥n (decryption-tool.py)

Para desencriptar y ver el reporte de tu sesi√≥n, necesitar√°s un script separado. Puedes crear un nuevo archivo `decryption-tool.py` y a√±adirle este c√≥digo:
```python
import getpass
import json
from Crypto.Cipher import AES
from Crypto.Protocol.KDF import PBKDF2

SALT_SIZE = 16
NONCE_SIZE = 16
TAG_SIZE = 16
KEY_SIZE = 32

def decrypt_data(encrypted_data: bytes, password: str) -> dict:
    """Desencripta datos encriptados con AES-256-GCM."""
    try:
        salt = encrypted_data[:SALT_SIZE]
        nonce = encrypted_data[SALT_SIZE:SALT_SIZE + NONCE_SIZE]
        tag = encrypted_data[SALT_SIZE + NONCE_SIZE:SALT_SIZE + NONCE_SIZE + TAG_SIZE]
        ciphertext = encrypted_data[SALT_SIZE + NONCE_SIZE + TAG_SIZE:]

        key = PBKDF2(password, salt, dkLen=KEY_SIZE, count=1000000)
        cipher = AES.new(key, AES.MODE_GCM, nonce=nonce)

        decrypted_payload = cipher.decrypt_and_verify(ciphertext, tag)
        
        return json.loads(decrypted_payload.decode('utf-8'))
    except (ValueError, KeyError):
        raise ValueError("Error de desencriptaci√≥n. Contrase√±a incorrecta o datos corruptos.")

def main():
    """CLI para desencriptar un reporte."""
    print("--- Desencriptador de Reportes Epic Mixer ---")
    file_path_input = input("Arrastra o pega la ruta al archivo .dat encriptado: ").strip()
    # Limpiar comillas si el usuario arrastra el archivo (com√∫n en Windows)
    file_path = file_path_input.replace("'", "").replace('"', '')
    
    try:
        with open(file_path, 'rb') as f:
            encrypted_data = f.read()
    except FileNotFoundError:
        print(f"‚ùå Error: Archivo no encontrado en la ruta: {file_path}")
        return
        
    password = getpass.getpass("üîë Introduce la contrase√±a de la sesi√≥n: ")
    
    try:
        decrypted_report = decrypt_data(encrypted_data, password)
        print("\n--- ‚úÖ Reporte Desencriptado ---")
        print(json.dumps(decrypted_report, indent=4))
        print("\n------------------------------")
    except ValueError as e:
        print(f"‚ùå Error: {e}")

if __name__ == "__main__":
    main()
```